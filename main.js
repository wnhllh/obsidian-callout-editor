/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty
var __getOwnPropDesc = Object.getOwnPropertyDescriptor
var __getOwnPropNames = Object.getOwnPropertyNames
var __hasOwnProp = Object.prototype.hasOwnProperty
var __export = (target, all) => {
	for (var name in all)
		__defProp(target, name, { get: all[name], enumerable: true })
}
var __copyProps = (to, from, except, desc) => {
	if ((from && typeof from === 'object') || typeof from === 'function') {
		for (let key of __getOwnPropNames(from))
			if (!__hasOwnProp.call(to, key) && key !== except)
				__defProp(to, key, {
					get: () => from[key],
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				})
	}
	return to
}
var __toCommonJS = (mod) =>
	__copyProps(__defProp({}, '__esModule', { value: true }), mod)

// main.ts
var main_exports = {}
__export(main_exports, {
	default: () => CalloutPlugin
})
module.exports = __toCommonJS(main_exports)
var import_obsidian6 = require('obsidian')

// src/global.ts
var numLines = 4
var vacantLines = 0
// var vacantList = []
var numCols = []
var contentList = []
var onEditingClass = 'on-editing'
var onEditingMulti = 'multi-editing'

// function getCaretPosition(editableElem) {
// 	let caretPos = 0,
// 		sel,
// 		range
// 	sel = activeWindow.getSelection()
// 	if (sel && sel.rangeCount) {
// 		range = sel.getRangeAt(0)
// 		caretPos = range.endOffset
// 		// if (range.commonAncestorContainer.parentNode == editableElem) {
// 		//   caretPos = range.endOffset;
// 		//   console.log("caretPos=", caretPos);
// 		// }
// 	}
// 	return caretPos
// }

// function setCaretPosition(editableElem, newPos) {
// 	let caretPos = 0,
// 		sel,
// 		range = activeDocument.createRange()
// 	sel = activeWindow.getSelection()
// 	if (sel && sel.rangeCount) {
// 		// range.setStart(editableElem.childNodes[0], newPos);
// 		range.setStart(editableElem.childNodes[1], newPos)
// 		range.collapse(true)
// 		sel.removeAllRanges()
// 		sel.addRange(range)
// 	}
// 	return caretPos
// }

function HTMLtoList0(rawContent) {
	let contentTemp = []
	let n = rawContent.length
	let i = 0
	while (n > 0) {
		if (!rawContent[i].startsWith('<button')) {
			if (rawContent[i].endsWith('</p>')) {
				rawContent[i] = rawContent[i].replace('</p>', '')
			}
			if (rawContent[i].startsWith('<p>')) {
				rawContent[i] = rawContent[i].replace('<p>', '')
			}
			if (rawContent[i].endsWith('<br>')) {
				// * 多个空行
				rawContent[i] = rawContent[i].replace(/<br>$/, '')
			}
			if (rawContent[i].contains('<br>')) {
				let temp = rawContent[i].split('<br>')
				n = n + temp.length - 1

				for (let j = 0; j < temp.length; j++) {
					rawContent.splice(i + j + 1, 0, temp[j])
				}
				rawContent.splice(i, 1)
			}

			if (rawContent[i].match(/<img.*?referrerpolicy="no-referrer">/g)) {
				const imgMatches = rawContent[i].match(
					/<img.*?referrerpolicy="no-referrer">/g
				)
				// 如果找到匹配项，则对每个匹配项进行替换
				if (imgMatches) {
					imgMatches.forEach((imgTag) => {
						// 将 <img> 标签转换为 Markdown 格式
						const imgUrl = imgTag.match(/\"(.*?)\"/)[1]
						const markdownImg = '![](' + imgUrl + ')'

						// 替换原内容中的 <img> 标签
						rawContent[i] = rawContent[i].replace(imgTag, markdownImg)
					})
				}
			}

			// if (rawContent[i].startsWith('<h1')) {
			// 	rawContent[i] =
			// 		'# ' + rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			// }
			// if (rawContent[i].startsWith('<h2')) {
			// 	rawContent[i] =
			// 		'## ' + rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			// }
			// if (rawContent[i].startsWith('<h3')) {
			// 	rawContent[i] =
			// 		'### ' + rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			//  }
			// if (rawContent[i].startsWith('<h4')) {
			// 	rawContent[i] =
			// 		'#### ' + rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			// }
			// if (rawContent[i].startsWith('<h5')) {
			// 	rawContent[i] =
			// 		'##### ' +
			// 		rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			// }

			// if (i !== 0) {
			// 	let k = 0
			// 	if(rawContent[i].endsWith('BRPLACEHOLDER')) {
			// 		rawContent[i] = rawContent[i].slice(0,-13);
			// 		k++;
			// 	}
			// contentTemp.push(rawContent[i])
			// while(k > 0){
			// 	contentTemp.push('')
			// 	k = 0;
			// }
			// }
			if (rawContent[i] !== '') {
				contentTemp.push(rawContent[i])
			} else {
				if (i !== 0 && i !== rawContent.length - 1) {
					vacantLines++
				}
			}
		}
		n--
		i++
	}

	return contentTemp
}

function HTMLtoList2(rawContent) {
	function processContent(item) {
		// 解析为DOM结构
		const doc = new DOMParser().parseFromString(
			`<div>${item}</div>`,
			'text/html'
		)
		const processNode = (node) => {
			if (node.nodeType === Node.ELEMENT_NODE) {
				let content = ''
				if (
					node.tagName === 'DIV' &&
					node.hasAttribute('data-callout-metadata')
				) {
					// 直接返回 [PLACEABLE] 替代符，或者根据需要处理Note的内容
					return '[PLACEABLE]'
				}
				switch (node.tagName) {
					case 'IMG':
						const src = node.getAttribute('src')
						content = `![](${src})`
						break
					case 'A':
						const href = node.getAttribute('href')
						content = `[${node.textContent}](${href})`
						break
					case 'STRONG':
						content = `**${processNode(node.firstChild)}**`
						break
					case 'EM':
						content = `*${processNode(node.firstChild)}*`
						break
					case 'DEL':
						content = `~~${processNode(node.firstChild)}~~`
						break
						case 'H1':
							case 'H2':
							case 'H3':
							case 'H4':
							case 'H5':
							case 'H6':
									// 提取标题级别数字（1至6）
									const level = parseInt(node.tagName[1], 10);
									// 根据标题级别构造Markdown标题前缀
									const pre = "#".repeat(level);
									// 处理标题内的内容，并添加前缀和换行符
									content = `${pre} ${processNode(node.firstChild)}\n`;
									break;
					case 'BR':
						return '\n'
					// 其他标签处理，如UL, LI等，或直接遍历子节点
					case 'UL':
					case 'OL':
						Array.from(node.childNodes).forEach((child) => {
							content += processNode(child, true, node.tagName)
						})
						break
					case 'LI':
						const prefix = listType === 'OL' ? '1. ' : '- '
						const checkbox = node.getAttribute('data-checked')
						if (checkbox !== null) {
							const checked = checkbox === 'true' ? '[x]' : '[ ]'
							content = `- ${checked} `
						} else {
							content = `${prefix}`
						}
						Array.from(node.childNodes).forEach((child) => {
							content += processNode(child)
						})
						if (!isListItem) content += '\n'
						break
					default:
						Array.from(node.childNodes).forEach((child) => {
							content += processNode(child)
						})
				}
				return content
			} else if (node.nodeType === Node.TEXT_NODE) {
				return node.textContent
			}
			return ''
		}

		// 将所有内容聚合为单个字符串，然后基于换行符分割
		const fullContent = processNode(doc.body.firstChild).trim()
		const processedNodes = fullContent
			.split('\n')
			.filter((line) => line.trim() !== '')

		return processedNodes
	}

	function processContentOptimized(htmlSegments) {
		// 将所有HTML片段合并为一个字符串
		// const fullHtml = htmlSegments.join('')
		const fullHtml = htmlSegments
			.map((segment) => (segment.endsWith('<br>') ? segment : segment + '<br>'))
			.join('')

		let filteredHtml = fullHtml.replace(
			/<div style="[^"]*"[^>]*>[\s\S]*?<\/div>/g,
			''
		)

		// 针对<div data-callout-metadata>元素及其全部内容的替换逻辑
		let processedHtml = filteredHtml
		.replace(/<\/p>\s*<p>/g, '<br>')
			.replace(
				/<div data-callout-metadata="[^"]*"[^>]*>([\s\S]*?)<\/div><\/div>/g,
				'\n[PLACEABLE]\n'
			)
			.replace(/<img src="([^"]+)"[^>]*>/g, '![]($1)')
			.replace(/<strong>(.*?)<\/strong>/g, '**$1**')
			.replace(/<em>(.*?)<\/em>/g, '*$1*')
			.replace(/<del>(.*?)<\/del>/g, '~~$1~~')
			.replace(/<h(\d)[^>]*>(.*?)<\/h\1>/g, (match, level, content) => {
        return `${'#'.repeat(parseInt(level, 10))} ${content.trim()}\n\n`;
    })
			.replace(
				/<ul class="contains-task-list">([\s\S]*?)<\/ul>/g,
				(match, listItems) => {
					// 未选中的任务列表项
					let uncheckedItems = listItems
						.replace(
							/<li data-task="" class="task-list-item"><input[^>]*>(.*?)<\/li>/g,
							'- [ ] $1\n'
						)
						.trim()
					// 选中的任务列表项
					let checkedItems = uncheckedItems
						.replace(
							/<li data-task="x" class="task-list-item is-checked"><input[^>]*checked=""[^>]*>(.*?)<\/li>/g,
							'- [x] $1\n'
						)
						.trim()
					return `\n${checkedItems}\n`
				}
			)

			// 新增：处理无序列表
			.replace(/<ul>([\s\S]*?)<\/ul>/g, (match, listItems) => {
				return listItems.replace(/<li>(.*?)<\/li>/g, '- $1\n').trim()
			})
			// 新增：处理有序列表
			.replace(/<ol>([\s\S]*?)<\/ol>/g, (match, listItems) => {
				let counter = 1
				return listItems
					.replace(/<li>(.*?)<\/li>/g, () => `${counter++}. $1\n`)
					.trim()
			})

			.replace(
				/<pre class="language-(\w+)" tabindex="\d+"><code class="language-\w+ is-loaded">(.*?)<\/code><button class="copy-code-button">[^<]*<\/button><\/pre>/g,
				(match, lang, code) =>
					`\`\`\`${lang}\n${code
						.replace(/&lt;/g, '<')
						.replace(/&gt;/g, '>')
						.replace(/&amp;/g, '&')}\n\`\`\`\n`
			)

			.replace(/<br\s*\/?>/g, '\n')
			.replace(/<[^>]+>/g, '')

		// 根据换行符分割处理后的内容
		const processedNodes = processedHtml
			.split('\n')
			.filter((line) => line.trim() !== '')

		return processedNodes
	}

	// 处理 rawContent 中的每一项
	// const processedContent = rawContent.flatMap((item) => processContent(item))
	//     .filter(item => item.trim() !== ''); // 过滤掉空白项

	const processedContent = processContentOptimized(rawContent)

	// 根据 Note 进行分组
	const groupedContent = []
	let currentGroup = []
	processedContent.forEach((item) => {
		if (item === '[PLACEABLE]') {
			if (currentGroup.length > 0) {
				groupedContent.push(currentGroup)
				currentGroup = []
			}
		} else {
			currentGroup.push(item)
		}
	})
	// 将最后一个分组加入到结果中
	if (currentGroup.length > 0) {
		groupedContent.push(currentGroup)
	}

	// console.log("1", groupedContent);
	return groupedContent
}

function HTMLtoList(rawContent) {
	// console.log('rawContent', rawContent)
	const newList = []
	let contentTemp = []

	// 首先，移除所有以 <button 开头的项
	rawContent = rawContent.filter((item) => !item.trim().startsWith('<button'))

	// 然后，找到并移除第一个以 <div data-callout-metadata 开头的项
	const divIndex = rawContent.findIndex((item) =>
		item.trim().startsWith('<div data-callout-metadata')
	)
	if (divIndex !== -1) {
		rawContent.splice(divIndex, 1)
	}

	for (let i = 0; i < rawContent.length; i++) {
		if (rawContent[i].endsWith('</p>')) {
			rawContent[i] = rawContent[i].replace('</p>', '')
			if (rawContent[i].startsWith('<p>')) {
				rawContent[i] = rawContent[i].replace('<p>', '')
			}
			if (rawContent[i].match(/<img.*?referrerpolicy="no-referrer">/g)) {
				const imgMatches = rawContent[i].match(
					/<img.*?referrerpolicy="no-referrer">/g
				)
				// 如果找到匹配项，则对每个匹配项进行替换
				if (imgMatches) {
					imgMatches.forEach((imgTag) => {
						// 将 <img> 标签转换为 Markdown 格式
						const imgUrl = imgTag.match(/\"(.*?)\"/)[1]
						const markdownImg = '![](' + imgUrl + ')'

						// 替换原内容中的 <img> 标签
						rawContent[i] = rawContent[i].replace(imgTag, markdownImg)
					})
				}
			}
			if (!rawContent[i].endsWith('<br>')) {
				if (
					rawContent[i].contains('<br')
					//&& !!rawContent[i].contains('span>')
				) {
					let temp = rawContent[i].split(/<br\s*\/?>|<br.*?>/gi)
					let style = ''
					for (let j = 0; j < temp.length; j++) {
						if (temp[j].contains('span')) {
							// if (temp[j].startsWith('<span') && !temp[j].endsWith('</span>')) {
							// 	style = temp[j]
							// 		.match(/style=\"(.*?)\"/)[0]
							// 		.replace(/style=\"(.*?)\"/, '$1')
							// 	temp[j] = temp[j] + '</span>'
							// }
							// if (temp[j].startsWith('</span>')) {
							// 	temp[j] = temp[j].replace('</span>', '')
							// }
							// if (temp[j].contains('</span>') && !temp[j].startsWith('<span')) {
							// 	temp[j] = '<span style="' + style + '">' + temp[j]
							// }
							temp[j] = temp[j].replace(/<span[^>]*>(.*?)<\/span>/gi, '$1')
						}
						contentTemp.push(temp[j])
					}
				} else {
					contentTemp.push(rawContent[i])
				}
			}
		}

		if (rawContent[i].endsWith('<br>')) {
			rawContent[i] = rawContent[i].substring(0, rawContent[i].length - 4)
			if (rawContent[i].startsWith('<p>')) {
				rawContent[i] = rawContent[i].replace('<p>', '')
			}
			if (rawContent[i].startsWith('<img')) {
				rawContent[i] =
					'![](' +
					rawContent[i].match(/\"(.*?)\"/)[0].replace(/\"(.*?)\"/, '$1') +
					')'
			}
			if (rawContent[i].contains('<br')) {
				let temp = rawContent[i].split(/<br\s*\/?>|<br.*?>/gi)
				let style = ''
				for (let j = 0; j < temp.length; j++) {
					if (temp[j].contains('span')) {
						// if (temp[j].startsWith('<span') && !temp[j].endsWith('</span>')) {
						// 	style = temp[j]
						// 		.match(/style=\"(.*?)\"/)[0]
						// 		.replace(/style=\"(.*?)\"/, '$1')
						// 	temp[j] = temp[j] + '</span>'
						// }
						// if (temp[j].startsWith('</span>')) {
						// 	temp[j] = temp[j].replace('</span>', '')
						// }
						// if (temp[j].contains('</span>') && !temp[j].startsWith('<span')) {
						// 	temp[j] = '<span style="' + style + '">' + temp[j]
						// }
						temp[j] = temp[j].replace(/<span[^>]*>(.*?)<\/span>/gi, '$1')
					}
					contentTemp.push(temp[j])
				}
			} else {
				contentTemp.push(rawContent[i])
			}
		}
		if (rawContent[i].startsWith('<h1')) {
			rawContent[i] =
				'# ' + rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			contentTemp.push(rawContent[i])
		}
		if (rawContent[i].startsWith('<h2')) {
			rawContent[i] =
				'## ' + rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			contentTemp.push(rawContent[i])
		}
		if (rawContent[i].startsWith('<h3')) {
			rawContent[i] =
				'### ' + rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			contentTemp.push(rawContent[i])
		}
		if (rawContent[i].startsWith('<h4')) {
			rawContent[i] =
				'#### ' + rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			contentTemp.push(rawContent[i])
		}
		if (rawContent[i].startsWith('<h5')) {
			rawContent[i] =
				'##### ' +
				rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			contentTemp.push(rawContent[i])
		}
		if (rawContent[i].startsWith('<h6')) {
			rawContent[i] =
				'###### ' +
				rawContent[i].match(/\>(.*?)\</)[0].replace(/\>(.*?)\</, '$1')
			contentTemp.push(rawContent[i])
		}
		if (
			rawContent[i].startsWith('</div></div>') ||
			rawContent[i].startsWith('<div data-callout-metadata') ||
			i == rawContent.length - 1
		) {
			// vacantList.push(0)
			let j = contentTemp.length - 1
			while (j >= 0) {
				if (contentTemp[j] == '') {
					contentTemp.splice(j, 1)
					// vacantList[vacantList.length - 1]++
					// vacantLines++
				}
				j--
			}

			newList.push(contentTemp)
			contentTemp = []
		}
	}
	return newList
}

// src/calloutEditor.ts
var import_obsidian = require('obsidian')

// src/editorUtils.ts
var getLineStartPos = (line) => ({
	line,
	ch: 0
})
var getLineEndPos = (line, editor) => ({
	line,
	ch: editor.getLine(line).length
})
var deleteLines = (editor, from, to) => {
	// console.log('deleteLines', from, ' ', to)
	if (to === editor.lastLine() + 1) {
		return replaceRangeWithoutScroll(
			editor,
			'',
			getLineEndPos(from - 1, editor),
			getLineEndPos(to, editor)
		)
	} else {
		return replaceRangeWithoutScroll(
			editor,
			'',
			getLineStartPos(from),
			getLineStartPos(to)
		)
	}
}
var deleteLine = (editor, line) => {
	return deleteLines(editor, line, line + 1)
}
var getLeadingWhitespace = (lineContent) => {
	const indentation = lineContent.match(/^\s+/)
	return indentation ? indentation[0] : ''
}
var insertLineBelow = (editor, line) => {
	// console.log('insertLineBelow', line)
	const endOfCurrentLine = getLineEndPos(line, editor)
	const indentation = getLeadingWhitespace(editor.getLine(line))
	return replaceRangeWithoutScroll(editor, '\n' + indentation, endOfCurrentLine)
}
var zf = (e, t) => {
	if (t.line < 0) return 0
	const n = t.line + 1
	if (n > e.lines) return e.length
	const i = e.line(n)
	return isFinite(t.ch)
		? t.ch < 0
			? i.from + Math.max(0, i.length + t.ch)
			: i.from + t.ch
		: i.to
}
var replaceRangeWithoutScroll = (editor, replacement, from, to) => {
	const cm = editor.cm
	const state = cm.state.doc
	const from2 = zf(state, from)
	const to2 = to ? zf(state, to) : from2
	return {
		changes: {
			from: from2,
			to: to2,
			insert: replacement
		},
		scrollIntoView: false,
		sequential: false
	}
}
var setLineWithoutScroll = (editor, n, text) => {
	// console.log('setLineWithoutScroll', n, text)
	const cm = editor.cm
	const state = cm.state.doc
	const from = zf(state, { line: n, ch: 0 })
	const to = zf(state, { line: n, ch: editor.getLine(n).length })
	return {
		changes: {
			from,
			to,
			insert: text
		},
		scrollIntoView: false,
		sequential: false
	}
}
function withoutScrollAndFocus(editorView, callback) {
	const scrollDom = editorView.scrollDOM
	const x = scrollDom.scrollLeft
	const y = scrollDom.scrollTop
	const resetScroll = () => {
		scrollDom.scrollTo(x, y)
	}
	scrollDom.addEventListener('scroll', resetScroll, true)
	editorView.contentDOM.blur()
	callback()
	editorView.contentDOM.blur()
	scrollDom.removeEventListener('scroll', resetScroll, true)
}

// src/calloutEditor.ts
var CalloutEditor = class {
	constructor(plugin) {
		this.plugin = plugin
	}

	static getLineNumber(callout, line) {
		return callout.fromLine + (line == 0 ? 0 : line + 1)
	}
	// async setLine(content) {
	//   const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
	//   const editor = markdownView == null ? void 0 : markdownView.editor;
	//   const editorView = editor == null ? void 0 : editor.cm;
	//   if (!editor || !editorView) {
	//     console.error("Cannot get editor");
	//     return;
	//   }
	//   console.log("set content: " + content)
	//   content = content.split("\n");
	//   withoutScrollAndFocus(editorView, () => {
	//       editorView.dispatch(setLineWithoutScroll(editor, editor.getCursor().line + 2 + content.length, "> "));
	//   });
	// }
	async updateLine(id, content) {
		const markdownView = this.plugin.app.workspace.getActiveViewOfType(
			import_obsidian.MarkdownView
		)
		const editor = markdownView == null ? void 0 : markdownView.editor
		const editorView = editor == null ? void 0 : editor.cm
		if (!editor || !editorView) {
			console.error('Cannot get editor')
			return
		}
		content = content.split('\n')
		const arr = id.split('_')
		withoutScrollAndFocus(editorView, () => {
			editorView.dispatch(
				insertLineBelow(editor, parseInt(arr[1]) + content.length)
			)
			editorView.dispatch(
				setLineWithoutScroll(
					editor,
					parseInt(arr[1]) + 1 + content.length,
					'> test case'
				)
			)
		})
	}

	async addCalloutContent(id, index) {
		const markdownView = this.plugin.app.workspace.getActiveViewOfType(
			import_obsidian.MarkdownView
		)
		const editor = markdownView == null ? void 0 : markdownView.editor
		const editorView = editor == null ? void 0 : editor.cm
		if (!editor || !editorView) {
			console.error('Cannot get editor')
			return
		}
		const arr = id.split('_')
		let n = 0
		let i = index
		while (i >= 0) {
			n = n + contentList[i].length + 2
			i--
		}

		let m = 0
		let k = index
		while (k > 0) {
			m = m + contentList[k - 1].length + 2
			k--
		}

		const lineNo = parseInt(arr[1]) + n

		withoutScrollAndFocus(editorView, () => {
			for (let i = 0; i < 3; i++) {
				editorView.dispatch(insertLineBelow(editor, lineNo + i))
			}

			editorView.dispatch(
				setLineWithoutScroll(
					editor,
					lineNo + 1,
					editor.getLine(parseInt(arr[1]) + m + 1)
				)
			)

			editorView.dispatch(setLineWithoutScroll(editor, lineNo + 2, '>> .'))
			editorView.dispatch(setLineWithoutScroll(editor, lineNo + 3, '>'))
		})
	}

	async updateChecklistItem(id, line, isChecked) {
		// console.log('updateChecklistItem', id, line, isChecked)

		const markdownView = this.plugin.app.workspace.getActiveViewOfType(
			import_obsidian.MarkdownView
		)
		const editor = markdownView == null ? void 0 : markdownView.editor
		const editorView = editor == null ? void 0 : editor.cm
		if (!editor || !editorView) {
			console.error('Cannot get editor')
			return
		}

		const currentLineContent = editor.getLine(line)
		const newLineContent = isChecked
			? currentLineContent.replace('[ ]', '[x]')
			: currentLineContent.replace('[x]', '[ ]')

		withoutScrollAndFocus(editorView, () => {
			editorView.dispatch(setLineWithoutScroll(editor, line, newLineContent))
		})
	}

	async updateCalloutTitle(id, index, newTitle) {
		const markdownView = this.plugin.app.workspace.getActiveViewOfType(
			import_obsidian.MarkdownView
		)
		const editor = markdownView == null ? void 0 : markdownView.editor
		const editorView = editor == null ? void 0 : editor.cm
		if (!editor || !editorView) {
			console.error('Cannot get editor')
			return
		}
		const arr = id.split('_')
		let n = 0
		while (index > 0) {
			n = n + contentList[index - 1].length + 2
			index--
		}
		const lineNo = parseInt(arr[1]) + n + 1 // Assuming this is the line number of the callout

		withoutScrollAndFocus(editorView, () => {
			const currentTitle = editor.getLine(lineNo)

			editorView.dispatch(
				setLineWithoutScroll(
					editor,
					lineNo,
					currentTitle.replace(/\s+[^\s\]]+](?=[^\]]*$)/, ' ' + newTitle + ']')
				)
			)
		})
	}

	async updateCallout(id, content, rawContent) {
		const markdownView = this.plugin.app.workspace.getActiveViewOfType(
			import_obsidian.MarkdownView
		)
		const editor = markdownView == null ? void 0 : markdownView.editor
		const editorView = editor == null ? void 0 : editor.cm
		if (!editor || !editorView) {
			console.error('Cannot get editor')
			return
		}

		// split content by line
		content = content.split('\n')
		const arr = id.split('_')

		const newList = HTMLtoList0(rawContent)

		// Prepare for inserting or deleting lines based on content length
		const startLineNum = parseInt(arr[1]) + 1
		const endLineNum = startLineNum + content.length

		let n = content.length - numLines

		// replace callout with new content
		withoutScrollAndFocus(editorView, () => {
			for (let i = 0; i < content.length - vacantLines; i++) {
				editorView.dispatch(
					setLineWithoutScroll(editor, startLineNum + i, '> ' + newList[i])
				)
				if (n > 0) {
					editorView.dispatch(insertLineBelow(editor, startLineNum + i))
					n--
				}
			}
			if (vacantLines > 0) {
				editorView.dispatch(
					deleteLines(editor, endLineNum - vacantLines, endLineNum)
				)
				vacantLines = 0
			}

			if (content.length < numLines) {
				editorView.dispatch(
					deleteLines(
						editor,
						endLineNum,
						endLineNum + numLines - content.length
					)
				)
			}
		})
		vacantLines = 0
	}

	async updateCallout2(id, content, rawContent) {
		const markdownView = this.plugin.app.workspace.getActiveViewOfType(
			import_obsidian.MarkdownView
		)
		const editor = markdownView == null ? void 0 : markdownView.editor
		const editorView = editor == null ? void 0 : editor.cm
		if (!editor || !editorView) {
			console.error('Cannot get editor')
			return
		}
		const arr = id.split('_')
		const baseLine = parseInt(arr[1])

		content = content.split('\n')
		for (let i = 0; i < content.length - 1; i++) {
			if (content[i].startsWith('Note')) {
				content.splice(i, 2)
			}
		}
		for (let i = 0; i < content.length - 1; i++) {
			if (content[i] == '' && content[i + 1] == '') {
				content.splice(i, 1)
			}
		}

		var newCols = []
		var numCol = []
		for (let i = 0; i < content.length; i++) {
			if (content[i] != '') {
				numCol.push(content[i])
			} else {
				newCols.push(numCol)
				numCol = []
			}
			if (i == content.length - 1) {
				newCols.push(numCol)
			}
		}

		const newList = HTMLtoList2(rawContent)

		// replace callout with new content
		var k = 0
		var m = 0
		var n = 0

		withoutScrollAndFocus(editorView, () => {
			for (let i = 0; i < newList.length; i++) {
				m = m + newList[i].length + 2
				n = n + contentList[i].length + 2
				if (newList[i].length > contentList[i].length) {
					const title = editor.getLine(baseLine + n + 1)
					for (let a = 0; a < newList[i].length - contentList[i].length; a++) {
						editorView.dispatch(insertLineBelow(editor, baseLine + n - 1))
					}
					editorView.dispatch(
						setLineWithoutScroll(
							editor,
							baseLine + n + newList[i].length - contentList[i].length + 1,
							title
						)
					)
					editorView.dispatch(
						setLineWithoutScroll(
							editor,
							baseLine + n + newList[i].length - contentList[i].length,
							'> '
						)
					)
				}

				for (let j = 0; j < newList[i].length; j++) {
					editorView.dispatch(
						setLineWithoutScroll(
							editor,
							baseLine + 2 + k,
							'>> ' + newList[i][j]
						)
					)
					k = k + 1
				}
				k = k + 2

				// if (vacantLines > 0) {
				// vacantList = []
				// vacantLines = 0
				// }

				if (newList[i].length < contentList[i].length) {
					editorView.dispatch(
						deleteLines(
							editor,
							baseLine + n - contentList[i].length + newList[i].length,
							baseLine + n - contentList[i].length + contentList[i].length
						)
					)
				}
			}
		})
		// vacantLines = 0
	}
}

// src/ext.ts
var import_view = require('@codemirror/view')
var getCalloutEditorExt = (
	plugin,
	updateTitleCallback,
	addContentCallback,
	updateChecklistCallback,
	settings
) =>
	import_view.ViewPlugin.fromClass(
		class {
			constructor(view) {
				this.settings = settings
				this.listenerMap = new Map()

				this.setupEventListeners(view)
			}
			destroy(view) {
				this.removeEventListeners()
			}
			update(update) {
				if (plugin.isInReadingView()) return
				const dom = update.view.contentDOM

				this.removeEventListeners(update.view)
				this.setupEventListeners(update.view)

				function generateCalloutSelector() {
					const baseKeywords = [
						'note',
						'tip',
						'abstract',
						'info',
						'todo',
						'success',
						'question',
						'warning',
						'failure',
						'danger',
						'bug',
						'example',
						'quote'
					]

					// 生成每个基础关键词及其"-"后缀形式的选择器
					const selectors = baseKeywords.flatMap((keyword) => [
						`.callout[data-callout='${keyword}']`,
						`.callout[data-callout^='${keyword}-']` // 使用 ^= 选择器匹配以 keyword- 开头的属性值
					])

					// 将所有选择器连接成一个字符串，用逗号分隔
					return selectors.join(', ')
				}

				const selector = generateCalloutSelector()
				const calloutEls = dom.querySelectorAll(selector)
				const columnsEls = dom.querySelectorAll(
					'.callout' && "div[data-callout='multi-column']"
				)

				calloutEls.forEach((calloutEl) => {
					// 检查当前 calloutEl 是否为 columnsEls 内的任何一个元素的后代
					const isInsideColumn = Array.from(columnsEls).some((columnEl) =>
						columnEl.contains(calloutEl)
					)

					// 如果 calloutEl 在 columnEl 内部，则不执行后续逻辑
					if (isInsideColumn) {
						return
					}

					const calloutPos = update.view.posAtDOM(calloutEl)
					const calloutLine = update.state.doc.lineAt(calloutPos).number - 1
					const calloutId = `callout_${calloutLine}`
					calloutEl.id = calloutId

					const calloutContent = calloutEl.querySelector('.callout-content')
					calloutContent.setAttribute('contenteditable', 'true')

					calloutContent.addEventListener('click', (e) => {
						e.preventDefault()
						e.stopPropagation()
						calloutEl.addClass(onEditingClass)
						// getCaretPosition(calloutContent);
						numLines = calloutContent.innerText.split('\n').length
						// const rawContent = calloutContent.innerHTML.split('\n')
						// console.log('callout clicked: ', numLines)
						// numLines = HTMLtoList0(rawContent).length;
						// console.log('callout clicked2: ', numLines)
					})
				})

				this.setupEventListeners(update.view)
			}

			setupEventListeners(view) {
				const columnsEls = view.contentDOM.querySelectorAll(
					'.callout' && "div[data-callout='multi-column']"
				)

				columnsEls.forEach((columnEl) => {
					const columnPos = view.posAtDOM(columnEl)
					const columnLine = view.state.doc.lineAt(columnPos).number - 1
					const columnId = `column_${columnLine}`

					// 设置元素ID和其他属性
					columnEl.id = columnId
					columnEl.childNodes.forEach((child) => {
						child.setAttribute('contenteditable', 'true')
					})

					this.setupColumnEl(columnEl, view)

					const columnContent = columnEl.querySelector('.callout-content')

					// 如果存在旧的事件处理函数，则移除它
					if (this.listenerMap.has(columnContent)) {
						const oldHandler = this.listenerMap.get(columnContent)
						columnContent.removeEventListener('click', oldHandler)
					}

					// 创建新的事件处理函数，它可以访问到columnId
					const newHandler = ((columnId) => {
						return (e) => {
							const target = e.target

							numCols = []
							var numCol = []
							e.preventDefault()
							e.stopPropagation()

							if (
								target.matches('input[type="checkbox"].task-list-item-checkbox')
							) {
								// 在这里调用处理复选框点击的逻辑
								// console.log('Checklist item clicked in', columnContent)
								const dataLine = target.getAttribute('data-line')
								let lineNumber = parseInt(dataLine, 10)
								const isChecked = target.checked
								lineNumber = lineNumber + columnLine
								updateChecklistCallback(columnId, lineNumber, isChecked)
							} else {
								columnEl.addClass(onEditingMulti)
								// console.log(getCaretPosition(columnContent));
								numLines = columnContent.innerText.split('\n').length
								// const rawContent2 = columnContent.innerHTML.split('\n')
								// numLines = HTMLtoList(rawContent2).length;
								const cards = columnContent.innerText.split('\n')
								for (let i = 0; i < cards.length; i++) {
									if (cards[i].startsWith('Note')) {
										cards.splice(i, 2)
									}
								}
								for (let i = 0; i < cards.length; i++) {
									if (cards[i] != '') {
										numCol.push(cards[i])
									} else {
										numCols.push(numCol)
										numCol = []
									}
									if (i == cards.length - 1) {
										numCols.push(numCol)
									}
								}

								let rawContent = columnContent.innerHTML.split('\n')
								rawContent = rawContent.filter(
									(line) => !line.trim().startsWith('<div style=')
								)

								contentList = HTMLtoList2(rawContent)
							}
						}
					})(columnId)

					// 为columnContent添加新的事件监听器，并存储引用
					columnContent.addEventListener('click', newHandler)
					this.listenerMap.set(columnContent, newHandler)
				})
			}

			// removeEventListeners(view) {
			// 	const contentDOM = view.contentDOM
			// 	if (this.handleCheckboxClick) {
			// 		contentDOM.removeEventListener('click', this.handleCheckboxClick)
			// 	}
			// }
			removeEventListeners() {
				// 遍历listenerMap中存储的每个元素及其监听器
				this.listenerMap.forEach((handler, element) => {
						// 对每个元素调用removeEventListener
						// 这里假设添加的监听器类型是'click'
						element.removeEventListener('click', handler);
				});
				
				// 清空listenerMap，释放引用
				this.listenerMap.clear();
		}
		

			setupColumnEl(columnEl, view) {
				const columnPos = view.posAtDOM(columnEl)
				const columnLine = view.state.doc.lineAt(columnPos).number - 1
				const columnId = `column_${columnLine}`

				// 设置元素ID和其他属性
				columnEl.id = columnId
				columnEl.childNodes.forEach((child) => {
					child.setAttribute('contenteditable', 'true')
				})

				const colors = [
					'transparent',
					'red',
					'orange',
					'yellow',
					'blue',
					'green',
					'white'
				]
				const calloutContents = columnEl.querySelectorAll(
					'.callout-content .callout-content'
				)

				calloutContents.forEach((content, index) => {
					if (this.settings.enableAddButton) {
						const addButton = document.createElement('div')
						addButton.innerHTML = `<svg t="1711969391120" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13056" width="12" height="20"><path d="M276.755 942.936c28.497 29.315 74.739 29.315 103.307 0l367.236-378.011c28.483-29.367 28.483-76.982 0-106.291l-367.236-377.997c-28.562-29.367-74.806-29.367-103.307 0-28.546 29.325-28.546 76.929 0 106.304l315.6 324.841-315.599 324.803c-28.545 29.367-28.544 76.973 0 106.356l0 0z" fill="#bfbfbf" p-id="13057"></path></svg>`
						addButton.style.position = 'absolute'
						addButton.style.right = '5.5px'
						addButton.style.top = '50%' // Set top to 50% of parent's height
						addButton.style.transform = 'translateY(-50%)' // Translate up by half of its height
						content.style.position = 'relative'
						content.appendChild(addButton)

						let isClickAllowed = true // 初始时允许点击

						addButton.addEventListener('click', (e) => {
							if (!isClickAllowed) return // 如果当前不允许点击，则直接返回

							// console.log(`Add button clicked in content ${index}`)
							addContentCallback(columnId, index)
							isClickAllowed = false // 禁用进一步的点击
							setTimeout(() => {
								isClickAllowed = true // 经过一定时间后重新允许点击
							}, 2000)
						})

						// 设置按钮的初始透明度
						addButton.style.opacity = '0'
						// 设置过渡效果为平滑过渡
						addButton.style.transition = 'opacity 0.3s'

						content.addEventListener('mousemove', (e) => {
							// 获取父容器的边界
							const rect = content.getBoundingClientRect()
							// 计算鼠标指针相对于父容器的X位置
							const mouseX = e.clientX - rect.left

							// 检查鼠标指针是否在父容器右侧10px内
							if (rect.width - mouseX <= 50) {
								// 如果是，则显示按钮
								addButton.style.opacity = '1'
							} else {
								// 如果不是，则隐藏按钮
								addButton.style.opacity = '0'
							}
						})
					}

					if (this.settings.enableSvgButton) {
						const svgButton = document.createElement('div')
						svgButton.innerHTML = `<svg t="1711969204609" class="icon" viewBox="0 0 1137 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6546" width="17" height="17"><path d="M14.222222 512C14.222222 185.002667 321.251556 9.671111 658.944 47.104c271.473778 30.151111 464.611556 214.129778 464.611556 440.661333 0 120.035556-60.586667 172.828444-180.110223 205.198223-8.135111 2.218667-15.815111 4.152889-30.776889 7.964444-51.939556 13.368889-72.590222 22.243556-81.294222 34.702222-10.865778 15.530667-11.719111 26.567111-6.428444 60.814222 1.877333 12.174222 2.616889 17.464889 3.356444 24.803556 6.030222 63.374222-20.081778 111.160889-96.028444 154.453333-87.438222 49.948444-265.557333 24.120889-421.034667-55.523555C130.844444 827.847111 14.222222 683.463111 14.222222 512zM649.500444 131.982222C356.181333 99.328 99.555556 245.930667 99.555556 512c0 134.257778 95.971556 253.041778 250.538666 332.231111 132.494222 67.868444 283.249778 89.713778 339.854222 57.400889 47.445333-27.079111 56.149333-43.064889 53.361778-72.305778a322.56 322.56 0 0 0-2.673778-19.911111c-8.419556-54.158222-6.144-84.195556 20.878223-122.766222 25.031111-35.84 57.116444-49.607111 129.877333-68.323556 15.075556-3.868444 22.186667-5.688889 29.752889-7.736889 86.641778-23.438222 117.077333-49.948444 117.077333-122.88 0-179.768889-157.866667-330.126222-388.721778-355.783111zM241.777778 430.762667a71.111111 71.111111 0 1 1 0 142.222222 71.111111 71.111111 0 0 1 0-142.222222z m455.111111-170.666667a71.111111 71.111111 0 1 1 0 142.222222 71.111111 71.111111 0 0 1 0-142.222222z m-284.444445-4.096a71.111111 71.111111 0 1 1 0 142.222222 71.111111 71.111111 0 0 1 0-142.222222z" fill="#bfbfbf" p-id="6547"></path></svg>`
						svgButton.style.position = 'absolute'
						svgButton.style.right = '4px'
						svgButton.style.bottom = '0'
						content.style.position = 'relative'
						content.appendChild(svgButton)

						// 设置按钮的初始透明度
						svgButton.style.opacity = '0'
						// 设置过渡效果为平滑过渡
						svgButton.style.transition = 'opacity 0.3s'

						content.addEventListener('mousemove', (e) => {
							// 获取父容器的边界
							const rect = content.getBoundingClientRect()
							// 计算鼠标指针相对于父容器的X位置
							const mouseX = e.clientX - rect.left

							// 检查鼠标指针是否在父容器右侧10px内
							if (rect.width - mouseX <= 50) {
								// 如果是，则显示按钮
								svgButton.style.opacity = '1'
							} else {
								// 如果不是，则隐藏按钮
								svgButton.style.opacity = '0'
							}
						})

						// 鼠标离开父容器时隐藏按钮
						content.addEventListener('mouseleave', () => {
							svgButton.style.opacity = '0'
						})

						// Create the color menu but don't append it yet
						const colorMenu = createColorMenu(colors, (selectedColor) => {
							// console.log('Selected color:', selectedColor)
							updateTitleCallback(columnId, index, selectedColor)
						})

						// Append and show/hide the menu on SVG icon click
						svgButton.addEventListener('click', (e) => {
							e.stopPropagation()
							if (!colorMenu.isConnected) {
								// If the menu isn't already in the DOM
								content.appendChild(colorMenu) // Append the menu
								colorMenu.style.display = 'block' // Make sure it's visible
							} else {
								colorMenu.style.display =
									colorMenu.style.display === 'none' ? 'block' : 'none' // Toggle display
							}
						})

						content.appendChild(colorMenu) // Initially add to DOM but hide
						colorMenu.style.display = 'none' // Start hidden
					}
				})

				function createColorMenu(colors, onSelect) {
					const menu = document.createElement('div')
					menu.style.position = 'absolute'
					menu.style.right = '22.5px'
					menu.style.bottom = '2.5px'
					menu.style.backgroundColor = '#fff'
					menu.style.border = '1px solid #ccc'
					menu.style.paddingTop = '2.5px'
					menu.style.paddingBottom = '2.5px'

					menu.style.zIndex = '1000'
					menu.style.borderRadius = '10px'

					menu.style.transform = 'scale(0.65)' // Scale down to 80% of the original size
					menu.style.transformOrigin = 'bottom right'
					// Explicitly setting the container width; adjust as necessary.
					menu.style.width = '250px' // Set a fixed width for the menu
					menu.style.overflowX = 'auto' // Allow horizontal scrolling
					menu.style.overflowY = 'hidden' // Prevent vertical scrolling
					menu.style.whiteSpace = 'nowrap' // Keep items in a single line
					menu.style.display = 'block' // Use block layout with nowrap to enforce horizontal layout

					colors.forEach((color) => {
						const colorOption = document.createElement('div')
						colorOption.textContent = '11' // Display the color value or adjust as needed

						colorOption.style.backgroundColor = color
						colorOption.style.color = color // Ensuring text is readable
						colorOption.style.fontSize = '15px'
						colorOption.style.display = 'inline-block' // Inline-block for horizontal alignment
						colorOption.style.padding = '0px 10px'
						colorOption.style.borderRadius = '10px'
						// colorOption.style.width = '15px'; // Optional: Adjust the width as needed
						// colorOption.style.height = '15px'; // Optional: Adjust the width as needed

						colorOption.style.margin = '2.5px' // Adds space between color options
						colorOption.style.height = '30px' // Optional: Adjust the height as needed
						colorOption.style.boxSizing = 'border-box' // Include padding and border in the element's total width and height
						colorOption.addEventListener('click', () => onSelect(color))
						menu.appendChild(colorOption)
					})

					return menu
				}
			}
		}
	)

// src/settings.ts
var import_obsidian5 = require('obsidian')
var DEFAULT_SETTINGS = {
	enableSvgButton: true, // 控制SVG按钮（选颜色）的显示
	enableAddButton: true // 控制添加内容按钮的显示
}

class CalloutPluginSettingTab extends import_obsidian5.PluginSettingTab {
	constructor(app, plugin) {
		super(app, plugin)
		this.plugin = plugin
	}

	display() {
		const { containerEl } = this
		containerEl.empty()

		containerEl.createEl('h2', { text: 'Callout Editor Settings' })

		// 为 enableSvgButton 添加设置项
		new import_obsidian5.Setting(containerEl)
			.setName('Enable Color Selection Button')
			.setDesc('Toggle to show or hide the Color Selection button.')
			.addToggle((toggle) =>
				toggle
					.setValue(this.plugin.settings.enableSvgButton)
					.onChange(async (value) => {
						this.plugin.settings.enableSvgButton = value
						await this.plugin.saveSettings()
					})
			)

		// 为 enableAddButton 添加设置项
		new import_obsidian5.Setting(containerEl)
			.setName('Enable Add Button')
			.setDesc('Toggle to show or hide the Add Content button.')
			.addToggle((toggle) =>
				toggle
					.setValue(this.plugin.settings.enableAddButton)
					.onChange(async (value) => {
						this.plugin.settings.enableAddButton = value
						await this.plugin.saveSettings()
					})
			)
	}
}

// main.ts
var CalloutPlugin = class extends import_obsidian6.Plugin {
	async onload() {
		await this.loadSettings()
		await this.loadCSS()
		this.calloutEditor = new CalloutEditor(this)
		let settings = DEFAULT_SETTINGS
		this.addSettingTab(new CalloutPluginSettingTab(this.app, this))
		const calloutEditorExt = getCalloutEditorExt(
			this,
			this.updateTitle.bind(this),
			this.addContent.bind(this),
			this.updateChecklistItem.bind(this),
			settings
		)
		this.registerEditorExtension(calloutEditorExt)
		this.registerEvent(
			this.app.workspace.on('file-open', async () => {
				// console.log('File opened!') // 用于调试，确保事件被正确触发

				this.app.workspace.onLayoutReady(() => {
					const markdownView = this.app.workspace.getActiveViewOfType(
						import_obsidian6.MarkdownView
					)
					if (!markdownView) return
					this.registerDomEvent(
						markdownView.contentEl,
						'click',
						async (e) => {
							const calloutEl = activeDocument.querySelector(
								'.' + onEditingClass
							)
							const columnEl = activeDocument.querySelector(
								'.' + onEditingMulti
							)

							// console.log('点击目标元素:', e.target)
							const target = e.target
							// 如果点击事件的目标元素是一个 contenteditable 元素
							if (target.isContentEditable) {
								// 检查其父元素是否是 callout-content 区域
								const parentCallout = target.closest('.callout-content')
								if (!parentCallout) {
									// 如果不是 callout-content 区域内的元素，则执行保存更改的逻辑
									if (calloutEl) {
										console.log('触发保存更改逻辑1')
										await this.saveChanges(calloutEl)
									}
									if (columnEl) {
										console.log('触发保存更改逻辑2')
										await this.saveChanges2(columnEl)
									}
								}

								if (
									columnEl &&
									target.closest('.callout-content') &&
									!target.closest('.callout-content .callout-content')
								) {
									// 如果存在columnEl，且点击的目标位于第一层.callout-content内部，但不在嵌套的.callout-content内
									// 调用saveChanges2
									await this.saveChanges2(columnEl)
								}
							}
						},
						true
					)
					this.registerDomEvent(
						markdownView.contentEl,
						'keydown',
						async (e) => {
							const calloutEl = activeDocument.querySelector(
								'.' + onEditingClass
							)
							const columnEl = activeDocument.querySelector(
								'.' + onEditingMulti
							)

							// if (!e.repeat && e.key === 'Enter' && !e.shiftKey) {
							// 	e.preventDefault() // 阻止默认的换段行为
							// 	const selection = window.getSelection()
							// 	const range = selection.getRangeAt(0)
							// 	const br = document.createElement('br')
							// 	range.insertNode(br) // 插入换行符
							// 	range.setStartAfter(br) // 将光标移动到换行符后
							// 	range.collapse(true) // 合并光标到范围的起点
							// 	selection.removeAllRanges()
							// 	selection.addRange(range) // 将新的范围添加到选区中
							// 	return
							// }
							if (!e.repeat && e.key == 'Shift' + 'Enter') {
								return
							}
							if (!e.repeat && e.key == 'Escape') {
								e.preventDefault()
								if (calloutEl) {
									await this.saveChanges(calloutEl)
								}
								if (columnEl) {
									await this.saveChanges2(columnEl)
								}
								return
							}
						}
					)
				})
				this.registerEvent()
			})
		)

		// 注册“插入两列”命令
		this.addCommand({
			id: 'insert-two-columns',
			name: 'Insert Two Columns Layout',
			editorCallback: (editor, view) => this.insertColumns(editor, 2)
		})

		// 注册“插入三列”命令
		this.addCommand({
			id: 'insert-three-columns',
			name: 'Insert Three Columns Layout',
			editorCallback: (editor, view) => this.insertColumns(editor, 3)
		})

		// 注册“插入四列”命令
		this.addCommand({
			id: 'insert-four-columns',
			name: 'Insert Four Columns Layout',
			editorCallback: (editor, view) => this.insertColumns(editor, 4)
		})

		// 注册“插入五列”命令
		this.addCommand({
			id: 'insert-five-columns',
			name: 'Insert Five Columns Layout',
			editorCallback: (editor, view) => this.insertColumns(editor, 5)
		})
	}

	insertColumns(editor, numberOfColumns) {
		let columnsMarkup = '> [!multi-column]\n'

		// 为了确保三列布局的宽度是精确的33%，我们可以特别处理这个情况
		let columnWidth = numberOfColumns === 3 ? 33 : 100 / numberOfColumns

		for (let i = 0; i < numberOfColumns; i++) {
			// 使用计算得到的columnWidth而不是直接除以numberOfColumns
			columnsMarkup += `>> [!Note | ${columnWidth}% notitle left grey]\n>> .\n>\n`
		}

		// 获取当前光标位置并插入文本
		const cursorPos = editor.getCursor()
		editor.replaceRange(columnsMarkup, cursorPos)
	}

	updateChecklistItem(id, line, isChecked) {
		this.calloutEditor.updateChecklistItem(id, line, isChecked)
	}

	updateTitle(id, index, newTitle) {
		this.calloutEditor.updateCalloutTitle(id, index, newTitle)
	}

	addContent(id, index) {
		this.calloutEditor.addCalloutContent(id, index)
	}

	async insertLine(calloutEl) {
		const el = activeDocument.querySelector('.' + onEditingClass)
		if (el instanceof HTMLDivElement) {
			calloutEl = el
		}
		await this.calloutEditor.updateLine(
			calloutEl.id,
			calloutEl.innerText.trim()
		)
	}
	async saveLine(calloutEl) {
		const el = activeDocument.querySelector('.' + onEditingClass)
		if (el instanceof HTMLDivElement) {
			calloutEl = el
		}
		calloutEl.setAttribute('contenteditable', false)
		calloutEl.removeClass(onEditingClass)
		await this.calloutEditor.updateLine(
			calloutEl.id,
			calloutEl.innerText.trim()
		)
	}

	async saveChanges(calloutEl) {
		const el = activeDocument.querySelector('.' + onEditingClass)
		if (el instanceof HTMLDivElement) {
			calloutEl = el
		}
		calloutEl.setAttribute('contenteditable', false)
		calloutEl.removeClass(onEditingClass)
		const calloutContent = calloutEl.querySelector('.callout-content')

		// 	const brPlaceholder = 'BRPLACEHOLDER';
		const content = calloutContent.innerText.trim()
		// 	const contentWithNewlines = calloutContent.innerHTML.replace(/(<br\s*\/?>)+/gi, function(match) {
		// 		// 计算匹配到的 <br> 的数量
		// 		const brCount = match.match(/<br\s*\/?>/gi).length;
		// 		// 除了最后一个 <br> 之外，其余的都替换为占位符
		// 		return brPlaceholder.repeat(brCount - 1) + '<br>';
		// });
		// 	console.log('contentWithNewlines:\n', contentWithNewlines);
		// 	const rawContent = contentWithNewlines.split('\n')

		let rawContent = calloutContent.innerHTML.split('\n')
		rawContent.filter((line) => !line.trim().startsWith('<div style='))

		// console.log('rawContent:\n', rawContent)
		// console.log('content:\n', content)

		await this.calloutEditor.updateCallout(calloutEl.id, content, rawContent)
	}
	async saveChanges2(calloutEl) {
		const el = activeDocument.querySelector('.' + onEditingMulti)
		if (el instanceof HTMLDivElement) {
			calloutEl = el
		}
		calloutEl.setAttribute('contenteditable', false)
		calloutEl.removeClass(onEditingMulti)
		const calloutContent = calloutEl.querySelector('.callout-content')
		const content = calloutContent.innerText.trim()
		let rawContent = calloutContent.innerHTML.split('\n')
		rawContent = rawContent.filter(
			(line) => !line.trim().startsWith('<div style=')
		)

		// console.log('rawContent:\n', rawContent)
		// console.log('content:\n', content)

		await this.calloutEditor.updateCallout2(calloutEl.id, content, rawContent)
	}

	isInReadingView() {
		const markdownView = this.app.workspace.getActiveViewOfType(
			import_obsidian6.MarkdownView
		)
		return (
			markdownView instanceof import_obsidian6.MarkdownView &&
			markdownView.getMode() == 'preview'
		)
	}
	async loadSettings() {
		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData())
	}
	async saveSettings() {
		await this.saveData(this.settings)
	}

	async loadCSS() {
		const cssFilePath = this.manifest.dir + '/styles.css'
		try {
			const cssContent = await this.app.vault.adapter.read(cssFilePath)
			const style = document.createElement('style')
			style.type = 'text/css'
			style.innerHTML = cssContent
			document.head.appendChild(style)
		} catch (error) {
			console.error('Failed to load CSS: ', error)
		}
	}

	onunload() {
		// const calloutEl = activeDocument.querySelector('.' + onEditingClass)
		// if (calloutEl) {
		// 	this.saveChanges(calloutEl)
		// }
		// const columnEl = activeDocument.querySelector('.' + onEditingMulti)
		// if (columnEl) {
		// 	this.saveChanges2(columnEl)
		// }
	}
}
